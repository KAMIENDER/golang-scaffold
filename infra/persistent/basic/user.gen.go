// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package basic

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/KAMIENDER/golang-scaffold/infra/persistent/po"
)

func newUser(db *gorm.DB, opts ...gen.DOOption) user {
	_user := user{}

	_user.userDo.UseDB(db, opts...)
	_user.userDo.UseModel(&po.User{})

	tableName := _user.userDo.TableName()
	_user.ALL = field.NewAsterisk(tableName)
	_user.ID = field.NewInt(tableName, "id")
	_user.Name = field.NewString(tableName, "name")
	_user.Email = field.NewString(tableName, "email")
	_user.Password = field.NewString(tableName, "password")
	_user.ConfirmSelector = field.NewString(tableName, "confirm_selector")
	_user.ConfirmVerifier = field.NewString(tableName, "confirm_verifier")
	_user.Confirmed = field.NewBool(tableName, "confirmed")
	_user.AttemptCount = field.NewInt(tableName, "attempt_count")
	_user.LastAttempt = field.NewTime(tableName, "last_attempt")
	_user.Locked = field.NewTime(tableName, "locked")
	_user.RecoverSelector = field.NewString(tableName, "recover_selector")
	_user.RecoverVerifier = field.NewString(tableName, "recover_verifier")
	_user.RecoverTokenExpiry = field.NewTime(tableName, "recover_token_expiry")
	_user.OAuth2UID = field.NewString(tableName, "OAuth_2_uid")
	_user.OAuth2Provider = field.NewString(tableName, "OAuth_2_provider")
	_user.OAuth2AccessToken = field.NewString(tableName, "OAuth_2_access_token")
	_user.OAuth2RefreshToken = field.NewString(tableName, "OAuth_2_refresh_token")
	_user.OAuth2Expiry = field.NewTime(tableName, "OAuth_2_expiry")
	_user.TOTPSecretKey = field.NewString(tableName, "TOTP_Secret_key")
	_user.SMSPhoneNumber = field.NewString(tableName, "SMS_phone_number")
	_user.SMSSeedPhoneNumber = field.NewString(tableName, "SMS_seed_phone_number")
	_user.RecoveryCodes = field.NewString(tableName, "recovery_codes")
	_user.UserID = field.NewInt(tableName, "user_id")
	_user.BardID = field.NewInt(tableName, "bard_id")
	_user.CreatedTime = field.NewInt64(tableName, "created_time")
	_user.DeletedTime = field.NewInt64(tableName, "deleted_time")
	_user.ModifiedTime = field.NewInt64(tableName, "modified_time")

	_user.fillFieldMap()

	return _user
}

type user struct {
	userDo userDo

	ALL                field.Asterisk
	ID                 field.Int
	Name               field.String
	Email              field.String
	Password           field.String
	ConfirmSelector    field.String
	ConfirmVerifier    field.String
	Confirmed          field.Bool
	AttemptCount       field.Int
	LastAttempt        field.Time
	Locked             field.Time
	RecoverSelector    field.String
	RecoverVerifier    field.String
	RecoverTokenExpiry field.Time
	OAuth2UID          field.String
	OAuth2Provider     field.String
	OAuth2AccessToken  field.String
	OAuth2RefreshToken field.String
	OAuth2Expiry       field.Time
	TOTPSecretKey      field.String
	SMSPhoneNumber     field.String
	SMSSeedPhoneNumber field.String
	RecoveryCodes      field.String
	UserID             field.Int
	BardID             field.Int
	CreatedTime        field.Int64
	DeletedTime        field.Int64
	ModifiedTime       field.Int64

	fieldMap map[string]field.Expr
}

func (u user) Table(newTableName string) *user {
	u.userDo.UseTable(newTableName)
	return u.updateTableName(newTableName)
}

func (u user) As(alias string) *user {
	u.userDo.DO = *(u.userDo.As(alias).(*gen.DO))
	return u.updateTableName(alias)
}

func (u *user) updateTableName(table string) *user {
	u.ALL = field.NewAsterisk(table)
	u.ID = field.NewInt(table, "id")
	u.Name = field.NewString(table, "name")
	u.Email = field.NewString(table, "email")
	u.Password = field.NewString(table, "password")
	u.ConfirmSelector = field.NewString(table, "confirm_selector")
	u.ConfirmVerifier = field.NewString(table, "confirm_verifier")
	u.Confirmed = field.NewBool(table, "confirmed")
	u.AttemptCount = field.NewInt(table, "attempt_count")
	u.LastAttempt = field.NewTime(table, "last_attempt")
	u.Locked = field.NewTime(table, "locked")
	u.RecoverSelector = field.NewString(table, "recover_selector")
	u.RecoverVerifier = field.NewString(table, "recover_verifier")
	u.RecoverTokenExpiry = field.NewTime(table, "recover_token_expiry")
	u.OAuth2UID = field.NewString(table, "OAuth_2_uid")
	u.OAuth2Provider = field.NewString(table, "OAuth_2_provider")
	u.OAuth2AccessToken = field.NewString(table, "OAuth_2_access_token")
	u.OAuth2RefreshToken = field.NewString(table, "OAuth_2_refresh_token")
	u.OAuth2Expiry = field.NewTime(table, "OAuth_2_expiry")
	u.TOTPSecretKey = field.NewString(table, "TOTP_Secret_key")
	u.SMSPhoneNumber = field.NewString(table, "SMS_phone_number")
	u.SMSSeedPhoneNumber = field.NewString(table, "SMS_seed_phone_number")
	u.RecoveryCodes = field.NewString(table, "recovery_codes")
	u.UserID = field.NewInt(table, "user_id")
	u.BardID = field.NewInt(table, "bard_id")
	u.CreatedTime = field.NewInt64(table, "created_time")
	u.DeletedTime = field.NewInt64(table, "deleted_time")
	u.ModifiedTime = field.NewInt64(table, "modified_time")

	u.fillFieldMap()

	return u
}

func (u *user) WithContext(ctx context.Context) *userDo { return u.userDo.WithContext(ctx) }

func (u user) TableName() string { return u.userDo.TableName() }

func (u user) Alias() string { return u.userDo.Alias() }

func (u *user) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := u.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (u *user) fillFieldMap() {
	u.fieldMap = make(map[string]field.Expr, 27)
	u.fieldMap["id"] = u.ID
	u.fieldMap["name"] = u.Name
	u.fieldMap["email"] = u.Email
	u.fieldMap["password"] = u.Password
	u.fieldMap["confirm_selector"] = u.ConfirmSelector
	u.fieldMap["confirm_verifier"] = u.ConfirmVerifier
	u.fieldMap["confirmed"] = u.Confirmed
	u.fieldMap["attempt_count"] = u.AttemptCount
	u.fieldMap["last_attempt"] = u.LastAttempt
	u.fieldMap["locked"] = u.Locked
	u.fieldMap["recover_selector"] = u.RecoverSelector
	u.fieldMap["recover_verifier"] = u.RecoverVerifier
	u.fieldMap["recover_token_expiry"] = u.RecoverTokenExpiry
	u.fieldMap["OAuth_2_uid"] = u.OAuth2UID
	u.fieldMap["OAuth_2_provider"] = u.OAuth2Provider
	u.fieldMap["OAuth_2_access_token"] = u.OAuth2AccessToken
	u.fieldMap["OAuth_2_refresh_token"] = u.OAuth2RefreshToken
	u.fieldMap["OAuth_2_expiry"] = u.OAuth2Expiry
	u.fieldMap["TOTP_Secret_key"] = u.TOTPSecretKey
	u.fieldMap["SMS_phone_number"] = u.SMSPhoneNumber
	u.fieldMap["SMS_seed_phone_number"] = u.SMSSeedPhoneNumber
	u.fieldMap["recovery_codes"] = u.RecoveryCodes
	u.fieldMap["user_id"] = u.UserID
	u.fieldMap["bard_id"] = u.BardID
	u.fieldMap["created_time"] = u.CreatedTime
	u.fieldMap["deleted_time"] = u.DeletedTime
	u.fieldMap["modified_time"] = u.ModifiedTime
}

func (u user) clone(db *gorm.DB) user {
	u.userDo.ReplaceConnPool(db.Statement.ConnPool)
	return u
}

func (u user) replaceDB(db *gorm.DB) user {
	u.userDo.ReplaceDB(db)
	return u
}

type userDo struct{ gen.DO }

func (u userDo) Debug() *userDo {
	return u.withDO(u.DO.Debug())
}

func (u userDo) WithContext(ctx context.Context) *userDo {
	return u.withDO(u.DO.WithContext(ctx))
}

func (u userDo) ReadDB() *userDo {
	return u.Clauses(dbresolver.Read)
}

func (u userDo) WriteDB() *userDo {
	return u.Clauses(dbresolver.Write)
}

func (u userDo) Session(config *gorm.Session) *userDo {
	return u.withDO(u.DO.Session(config))
}

func (u userDo) Clauses(conds ...clause.Expression) *userDo {
	return u.withDO(u.DO.Clauses(conds...))
}

func (u userDo) Returning(value interface{}, columns ...string) *userDo {
	return u.withDO(u.DO.Returning(value, columns...))
}

func (u userDo) Not(conds ...gen.Condition) *userDo {
	return u.withDO(u.DO.Not(conds...))
}

func (u userDo) Or(conds ...gen.Condition) *userDo {
	return u.withDO(u.DO.Or(conds...))
}

func (u userDo) Select(conds ...field.Expr) *userDo {
	return u.withDO(u.DO.Select(conds...))
}

func (u userDo) Where(conds ...gen.Condition) *userDo {
	return u.withDO(u.DO.Where(conds...))
}

func (u userDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) *userDo {
	return u.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (u userDo) Order(conds ...field.Expr) *userDo {
	return u.withDO(u.DO.Order(conds...))
}

func (u userDo) Distinct(cols ...field.Expr) *userDo {
	return u.withDO(u.DO.Distinct(cols...))
}

func (u userDo) Omit(cols ...field.Expr) *userDo {
	return u.withDO(u.DO.Omit(cols...))
}

func (u userDo) Join(table schema.Tabler, on ...field.Expr) *userDo {
	return u.withDO(u.DO.Join(table, on...))
}

func (u userDo) LeftJoin(table schema.Tabler, on ...field.Expr) *userDo {
	return u.withDO(u.DO.LeftJoin(table, on...))
}

func (u userDo) RightJoin(table schema.Tabler, on ...field.Expr) *userDo {
	return u.withDO(u.DO.RightJoin(table, on...))
}

func (u userDo) Group(cols ...field.Expr) *userDo {
	return u.withDO(u.DO.Group(cols...))
}

func (u userDo) Having(conds ...gen.Condition) *userDo {
	return u.withDO(u.DO.Having(conds...))
}

func (u userDo) Limit(limit int) *userDo {
	return u.withDO(u.DO.Limit(limit))
}

func (u userDo) Offset(offset int) *userDo {
	return u.withDO(u.DO.Offset(offset))
}

func (u userDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *userDo {
	return u.withDO(u.DO.Scopes(funcs...))
}

func (u userDo) Unscoped() *userDo {
	return u.withDO(u.DO.Unscoped())
}

func (u userDo) Create(values ...*po.User) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Create(values)
}

func (u userDo) CreateInBatches(values []*po.User, batchSize int) error {
	return u.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (u userDo) Save(values ...*po.User) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Save(values)
}

func (u userDo) First() (*po.User, error) {
	if result, err := u.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*po.User), nil
	}
}

func (u userDo) Take() (*po.User, error) {
	if result, err := u.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*po.User), nil
	}
}

func (u userDo) Last() (*po.User, error) {
	if result, err := u.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*po.User), nil
	}
}

func (u userDo) Find() ([]*po.User, error) {
	result, err := u.DO.Find()
	return result.([]*po.User), err
}

func (u userDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*po.User, err error) {
	buf := make([]*po.User, 0, batchSize)
	err = u.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (u userDo) FindInBatches(result *[]*po.User, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return u.DO.FindInBatches(result, batchSize, fc)
}

func (u userDo) Attrs(attrs ...field.AssignExpr) *userDo {
	return u.withDO(u.DO.Attrs(attrs...))
}

func (u userDo) Assign(attrs ...field.AssignExpr) *userDo {
	return u.withDO(u.DO.Assign(attrs...))
}

func (u userDo) Joins(fields ...field.RelationField) *userDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Joins(_f))
	}
	return &u
}

func (u userDo) Preload(fields ...field.RelationField) *userDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Preload(_f))
	}
	return &u
}

func (u userDo) FirstOrInit() (*po.User, error) {
	if result, err := u.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*po.User), nil
	}
}

func (u userDo) FirstOrCreate() (*po.User, error) {
	if result, err := u.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*po.User), nil
	}
}

func (u userDo) FindByPage(offset int, limit int) (result []*po.User, count int64, err error) {
	result, err = u.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = u.Offset(-1).Limit(-1).Count()
	return
}

func (u userDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	err = u.Offset(offset).Limit(limit).Scan(result)
	return
}

func (u userDo) Scan(result interface{}) (err error) {
	return u.DO.Scan(result)
}

func (u userDo) Delete(models ...*po.User) (result gen.ResultInfo, err error) {
	return u.DO.Delete(models)
}

func (u *userDo) withDO(do gen.Dao) *userDo {
	u.DO = *do.(*gen.DO)
	return u
}
